"use strict";
/*!
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AWSLambdaTriggerPlugin = void 0;
var tslib_1 = require("tslib");
var AgentConfig_1 = tslib_1.__importDefault(require("../config/AgentConfig"));
var ContextManager_1 = tslib_1.__importDefault(require("../trace/context/ContextManager"));
var Component_1 = require("../trace/Component");
var index_1 = tslib_1.__importDefault(require("../index"));
var AWSLambdaTriggerPlugin = /** @class */ (function () {
    function AWSLambdaTriggerPlugin() {
    }
    // default working start function, should be overridden by the various types of lambda trigger subclasses
    AWSLambdaTriggerPlugin.prototype.start = function (event, context) {
        var span = ContextManager_1.default.current.newEntrySpan(context.functionName ? "/" + context.functionName : '/');
        span.component = Component_1.Component.AWSLAMBDA_FUNCTION;
        span.peer = 'Unknown';
        span.start();
        return span;
    };
    // default working stop function
    AWSLambdaTriggerPlugin.prototype.stop = function (span, err, res) {
        span.stop();
    };
    AWSLambdaTriggerPlugin.prototype.wrap = function (func) {
        var _this = this;
        return function (event, context, callback) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
            var span, ret, stop, resolve, reject, callbackDone, callbackPromise, _a, _b, e_1;
            var _this = this;
            return tslib_1.__generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        ContextManager_1.default.removeTailFinishedContexts(); // need this because AWS seems to chain sequential independent operations linearly instead of hierarchically
                        span = this.start(event, context);
                        stop = function (err, res) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var p;
                            var _this = this;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        stop = function (err, res) { return tslib_1.__awaiter(_this, void 0, void 0, function () { return tslib_1.__generator(this, function (_a) {
                                            return [2 /*return*/];
                                        }); }); };
                                        this.stop(span, err, res);
                                        if (!AgentConfig_1.default.awsLambdaFlush) return [3 /*break*/, 3];
                                        return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, 0); })];
                                    case 1:
                                        _a.sent(); // child spans of this span may have finalization waiting in the event loop in which case we give them a chance to run so that the segment can be archived properly for flushing
                                        p = index_1.default.flush();
                                        if (!p) return [3 /*break*/, 3];
                                        return [4 /*yield*/, p];
                                    case 2:
                                        _a.sent();
                                        _a.label = 3;
                                    case 3: return [2 /*return*/, res];
                                }
                            });
                        }); };
                        callbackDone = false;
                        callbackPromise = new Promise(function (_resolve, _reject) {
                            resolve = _resolve;
                            reject = _reject;
                        });
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 4, , 6]);
                        ret = func(event, context, function (err, res) {
                            if (!callbackDone) {
                                callbackDone = true;
                                if (err)
                                    reject(err);
                                else
                                    resolve(res);
                            }
                        });
                        if (typeof (ret === null || ret === void 0 ? void 0 : ret.then) !== 'function')
                            // generic Promise check
                            ret = callbackPromise;
                        _a = stop;
                        _b = [null];
                        return [4 /*yield*/, ret];
                    case 2: return [4 /*yield*/, _a.apply(void 0, _b.concat([_c.sent()]))];
                    case 3: return [2 /*return*/, _c.sent()];
                    case 4:
                        e_1 = _c.sent();
                        span.error(e_1);
                        return [4 /*yield*/, stop(e_1, null)];
                    case 5:
                        _c.sent();
                        throw e_1;
                    case 6: return [2 /*return*/];
                }
            });
        }); };
    };
    return AWSLambdaTriggerPlugin;
}());
exports.AWSLambdaTriggerPlugin = AWSLambdaTriggerPlugin;
// noinspection JSUnusedGlobalSymbols
exports.default = new AWSLambdaTriggerPlugin();
//# sourceMappingURL=AWSLambdaTriggerPlugin.js.map