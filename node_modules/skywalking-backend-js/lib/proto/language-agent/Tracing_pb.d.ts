// package: skywalking.v3
// file: language-agent/Tracing.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as common_Common_pb from "../common/Common_pb";

export class SegmentObject extends jspb.Message { 
    getTraceid(): string;
    setTraceid(value: string): SegmentObject;
    getTracesegmentid(): string;
    setTracesegmentid(value: string): SegmentObject;
    clearSpansList(): void;
    getSpansList(): Array<SpanObject>;
    setSpansList(value: Array<SpanObject>): SegmentObject;
    addSpans(value?: SpanObject, index?: number): SpanObject;
    getService(): string;
    setService(value: string): SegmentObject;
    getServiceinstance(): string;
    setServiceinstance(value: string): SegmentObject;
    getIssizelimited(): boolean;
    setIssizelimited(value: boolean): SegmentObject;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SegmentObject.AsObject;
    static toObject(includeInstance: boolean, msg: SegmentObject): SegmentObject.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SegmentObject, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SegmentObject;
    static deserializeBinaryFromReader(message: SegmentObject, reader: jspb.BinaryReader): SegmentObject;
}

export namespace SegmentObject {
    export type AsObject = {
        traceid: string,
        tracesegmentid: string,
        spansList: Array<SpanObject.AsObject>,
        service: string,
        serviceinstance: string,
        issizelimited: boolean,
    }
}

export class SegmentReference extends jspb.Message { 
    getReftype(): RefType;
    setReftype(value: RefType): SegmentReference;
    getTraceid(): string;
    setTraceid(value: string): SegmentReference;
    getParenttracesegmentid(): string;
    setParenttracesegmentid(value: string): SegmentReference;
    getParentspanid(): number;
    setParentspanid(value: number): SegmentReference;
    getParentservice(): string;
    setParentservice(value: string): SegmentReference;
    getParentserviceinstance(): string;
    setParentserviceinstance(value: string): SegmentReference;
    getParentendpoint(): string;
    setParentendpoint(value: string): SegmentReference;
    getNetworkaddressusedatpeer(): string;
    setNetworkaddressusedatpeer(value: string): SegmentReference;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SegmentReference.AsObject;
    static toObject(includeInstance: boolean, msg: SegmentReference): SegmentReference.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SegmentReference, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SegmentReference;
    static deserializeBinaryFromReader(message: SegmentReference, reader: jspb.BinaryReader): SegmentReference;
}

export namespace SegmentReference {
    export type AsObject = {
        reftype: RefType,
        traceid: string,
        parenttracesegmentid: string,
        parentspanid: number,
        parentservice: string,
        parentserviceinstance: string,
        parentendpoint: string,
        networkaddressusedatpeer: string,
    }
}

export class SpanObject extends jspb.Message { 
    getSpanid(): number;
    setSpanid(value: number): SpanObject;
    getParentspanid(): number;
    setParentspanid(value: number): SpanObject;
    getStarttime(): number;
    setStarttime(value: number): SpanObject;
    getEndtime(): number;
    setEndtime(value: number): SpanObject;
    clearRefsList(): void;
    getRefsList(): Array<SegmentReference>;
    setRefsList(value: Array<SegmentReference>): SpanObject;
    addRefs(value?: SegmentReference, index?: number): SegmentReference;
    getOperationname(): string;
    setOperationname(value: string): SpanObject;
    getPeer(): string;
    setPeer(value: string): SpanObject;
    getSpantype(): SpanType;
    setSpantype(value: SpanType): SpanObject;
    getSpanlayer(): SpanLayer;
    setSpanlayer(value: SpanLayer): SpanObject;
    getComponentid(): number;
    setComponentid(value: number): SpanObject;
    getIserror(): boolean;
    setIserror(value: boolean): SpanObject;
    clearTagsList(): void;
    getTagsList(): Array<common_Common_pb.KeyStringValuePair>;
    setTagsList(value: Array<common_Common_pb.KeyStringValuePair>): SpanObject;
    addTags(value?: common_Common_pb.KeyStringValuePair, index?: number): common_Common_pb.KeyStringValuePair;
    clearLogsList(): void;
    getLogsList(): Array<Log>;
    setLogsList(value: Array<Log>): SpanObject;
    addLogs(value?: Log, index?: number): Log;
    getSkipanalysis(): boolean;
    setSkipanalysis(value: boolean): SpanObject;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SpanObject.AsObject;
    static toObject(includeInstance: boolean, msg: SpanObject): SpanObject.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SpanObject, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SpanObject;
    static deserializeBinaryFromReader(message: SpanObject, reader: jspb.BinaryReader): SpanObject;
}

export namespace SpanObject {
    export type AsObject = {
        spanid: number,
        parentspanid: number,
        starttime: number,
        endtime: number,
        refsList: Array<SegmentReference.AsObject>,
        operationname: string,
        peer: string,
        spantype: SpanType,
        spanlayer: SpanLayer,
        componentid: number,
        iserror: boolean,
        tagsList: Array<common_Common_pb.KeyStringValuePair.AsObject>,
        logsList: Array<Log.AsObject>,
        skipanalysis: boolean,
    }
}

export class Log extends jspb.Message { 
    getTime(): number;
    setTime(value: number): Log;
    clearDataList(): void;
    getDataList(): Array<common_Common_pb.KeyStringValuePair>;
    setDataList(value: Array<common_Common_pb.KeyStringValuePair>): Log;
    addData(value?: common_Common_pb.KeyStringValuePair, index?: number): common_Common_pb.KeyStringValuePair;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Log.AsObject;
    static toObject(includeInstance: boolean, msg: Log): Log.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Log, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Log;
    static deserializeBinaryFromReader(message: Log, reader: jspb.BinaryReader): Log;
}

export namespace Log {
    export type AsObject = {
        time: number,
        dataList: Array<common_Common_pb.KeyStringValuePair.AsObject>,
    }
}

export class ID extends jspb.Message { 
    clearIdList(): void;
    getIdList(): Array<string>;
    setIdList(value: Array<string>): ID;
    addId(value: string, index?: number): string;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): ID.AsObject;
    static toObject(includeInstance: boolean, msg: ID): ID.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: ID, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): ID;
    static deserializeBinaryFromReader(message: ID, reader: jspb.BinaryReader): ID;
}

export namespace ID {
    export type AsObject = {
        idList: Array<string>,
    }
}

export class SegmentCollection extends jspb.Message { 
    clearSegmentsList(): void;
    getSegmentsList(): Array<SegmentObject>;
    setSegmentsList(value: Array<SegmentObject>): SegmentCollection;
    addSegments(value?: SegmentObject, index?: number): SegmentObject;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): SegmentCollection.AsObject;
    static toObject(includeInstance: boolean, msg: SegmentCollection): SegmentCollection.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: SegmentCollection, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): SegmentCollection;
    static deserializeBinaryFromReader(message: SegmentCollection, reader: jspb.BinaryReader): SegmentCollection;
}

export namespace SegmentCollection {
    export type AsObject = {
        segmentsList: Array<SegmentObject.AsObject>,
    }
}

export enum SpanType {
    ENTRY = 0,
    EXIT = 1,
    LOCAL = 2,
}

export enum RefType {
    CROSSPROCESS = 0,
    CROSSTHREAD = 1,
}

export enum SpanLayer {
    UNKNOWN = 0,
    DATABASE = 1,
    RPCFRAMEWORK = 2,
    HTTP = 3,
    MQ = 4,
    CACHE = 5,
    FAAS = 6,
}
