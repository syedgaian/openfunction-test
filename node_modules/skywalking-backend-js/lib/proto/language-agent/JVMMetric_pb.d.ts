// package: skywalking.v3
// file: language-agent/JVMMetric.proto

/* tslint:disable */
/* eslint-disable */

import * as jspb from "google-protobuf";
import * as common_Common_pb from "../common/Common_pb";

export class JVMMetricCollection extends jspb.Message { 
    clearMetricsList(): void;
    getMetricsList(): Array<JVMMetric>;
    setMetricsList(value: Array<JVMMetric>): JVMMetricCollection;
    addMetrics(value?: JVMMetric, index?: number): JVMMetric;
    getService(): string;
    setService(value: string): JVMMetricCollection;
    getServiceinstance(): string;
    setServiceinstance(value: string): JVMMetricCollection;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): JVMMetricCollection.AsObject;
    static toObject(includeInstance: boolean, msg: JVMMetricCollection): JVMMetricCollection.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: JVMMetricCollection, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): JVMMetricCollection;
    static deserializeBinaryFromReader(message: JVMMetricCollection, reader: jspb.BinaryReader): JVMMetricCollection;
}

export namespace JVMMetricCollection {
    export type AsObject = {
        metricsList: Array<JVMMetric.AsObject>,
        service: string,
        serviceinstance: string,
    }
}

export class JVMMetric extends jspb.Message { 
    getTime(): number;
    setTime(value: number): JVMMetric;

    hasCpu(): boolean;
    clearCpu(): void;
    getCpu(): common_Common_pb.CPU | undefined;
    setCpu(value?: common_Common_pb.CPU): JVMMetric;
    clearMemoryList(): void;
    getMemoryList(): Array<Memory>;
    setMemoryList(value: Array<Memory>): JVMMetric;
    addMemory(value?: Memory, index?: number): Memory;
    clearMemorypoolList(): void;
    getMemorypoolList(): Array<MemoryPool>;
    setMemorypoolList(value: Array<MemoryPool>): JVMMetric;
    addMemorypool(value?: MemoryPool, index?: number): MemoryPool;
    clearGcList(): void;
    getGcList(): Array<GC>;
    setGcList(value: Array<GC>): JVMMetric;
    addGc(value?: GC, index?: number): GC;

    hasThread(): boolean;
    clearThread(): void;
    getThread(): Thread | undefined;
    setThread(value?: Thread): JVMMetric;

    hasClazz(): boolean;
    clearClazz(): void;
    getClazz(): Class | undefined;
    setClazz(value?: Class): JVMMetric;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): JVMMetric.AsObject;
    static toObject(includeInstance: boolean, msg: JVMMetric): JVMMetric.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: JVMMetric, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): JVMMetric;
    static deserializeBinaryFromReader(message: JVMMetric, reader: jspb.BinaryReader): JVMMetric;
}

export namespace JVMMetric {
    export type AsObject = {
        time: number,
        cpu?: common_Common_pb.CPU.AsObject,
        memoryList: Array<Memory.AsObject>,
        memorypoolList: Array<MemoryPool.AsObject>,
        gcList: Array<GC.AsObject>,
        thread?: Thread.AsObject,
        clazz?: Class.AsObject,
    }
}

export class Memory extends jspb.Message { 
    getIsheap(): boolean;
    setIsheap(value: boolean): Memory;
    getInit(): number;
    setInit(value: number): Memory;
    getMax(): number;
    setMax(value: number): Memory;
    getUsed(): number;
    setUsed(value: number): Memory;
    getCommitted(): number;
    setCommitted(value: number): Memory;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Memory.AsObject;
    static toObject(includeInstance: boolean, msg: Memory): Memory.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Memory, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Memory;
    static deserializeBinaryFromReader(message: Memory, reader: jspb.BinaryReader): Memory;
}

export namespace Memory {
    export type AsObject = {
        isheap: boolean,
        init: number,
        max: number,
        used: number,
        committed: number,
    }
}

export class MemoryPool extends jspb.Message { 
    getType(): PoolType;
    setType(value: PoolType): MemoryPool;
    getInit(): number;
    setInit(value: number): MemoryPool;
    getMax(): number;
    setMax(value: number): MemoryPool;
    getUsed(): number;
    setUsed(value: number): MemoryPool;
    getCommitted(): number;
    setCommitted(value: number): MemoryPool;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): MemoryPool.AsObject;
    static toObject(includeInstance: boolean, msg: MemoryPool): MemoryPool.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: MemoryPool, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): MemoryPool;
    static deserializeBinaryFromReader(message: MemoryPool, reader: jspb.BinaryReader): MemoryPool;
}

export namespace MemoryPool {
    export type AsObject = {
        type: PoolType,
        init: number,
        max: number,
        used: number,
        committed: number,
    }
}

export class GC extends jspb.Message { 
    getPhase(): GCPhase;
    setPhase(value: GCPhase): GC;
    getCount(): number;
    setCount(value: number): GC;
    getTime(): number;
    setTime(value: number): GC;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): GC.AsObject;
    static toObject(includeInstance: boolean, msg: GC): GC.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: GC, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): GC;
    static deserializeBinaryFromReader(message: GC, reader: jspb.BinaryReader): GC;
}

export namespace GC {
    export type AsObject = {
        phase: GCPhase,
        count: number,
        time: number,
    }
}

export class Thread extends jspb.Message { 
    getLivecount(): number;
    setLivecount(value: number): Thread;
    getDaemoncount(): number;
    setDaemoncount(value: number): Thread;
    getPeakcount(): number;
    setPeakcount(value: number): Thread;
    getRunnablestatethreadcount(): number;
    setRunnablestatethreadcount(value: number): Thread;
    getBlockedstatethreadcount(): number;
    setBlockedstatethreadcount(value: number): Thread;
    getWaitingstatethreadcount(): number;
    setWaitingstatethreadcount(value: number): Thread;
    getTimedwaitingstatethreadcount(): number;
    setTimedwaitingstatethreadcount(value: number): Thread;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Thread.AsObject;
    static toObject(includeInstance: boolean, msg: Thread): Thread.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Thread, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Thread;
    static deserializeBinaryFromReader(message: Thread, reader: jspb.BinaryReader): Thread;
}

export namespace Thread {
    export type AsObject = {
        livecount: number,
        daemoncount: number,
        peakcount: number,
        runnablestatethreadcount: number,
        blockedstatethreadcount: number,
        waitingstatethreadcount: number,
        timedwaitingstatethreadcount: number,
    }
}

export class Class extends jspb.Message { 
    getLoadedclasscount(): number;
    setLoadedclasscount(value: number): Class;
    getTotalunloadedclasscount(): number;
    setTotalunloadedclasscount(value: number): Class;
    getTotalloadedclasscount(): number;
    setTotalloadedclasscount(value: number): Class;

    serializeBinary(): Uint8Array;
    toObject(includeInstance?: boolean): Class.AsObject;
    static toObject(includeInstance: boolean, msg: Class): Class.AsObject;
    static extensions: {[key: number]: jspb.ExtensionFieldInfo<jspb.Message>};
    static extensionsBinary: {[key: number]: jspb.ExtensionFieldBinaryInfo<jspb.Message>};
    static serializeBinaryToWriter(message: Class, writer: jspb.BinaryWriter): void;
    static deserializeBinary(bytes: Uint8Array): Class;
    static deserializeBinaryFromReader(message: Class, reader: jspb.BinaryReader): Class;
}

export namespace Class {
    export type AsObject = {
        loadedclasscount: number,
        totalunloadedclasscount: number,
        totalloadedclasscount: number,
    }
}

export enum PoolType {
    CODE_CACHE_USAGE = 0,
    NEWGEN_USAGE = 1,
    OLDGEN_USAGE = 2,
    SURVIVOR_USAGE = 3,
    PERMGEN_USAGE = 4,
    METASPACE_USAGE = 5,
}

export enum GCPhase {
    NEW = 0,
    OLD = 1,
    NORMAL = 2,
}
