"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ActorReminderData_1 = __importDefault(require("./ActorReminderData"));
const ActorTimerData_1 = __importDefault(require("./ActorTimerData"));
const BufferSerializer_1 = __importDefault(require("./BufferSerializer"));
/**
 * The Actor Manager manages actor objects of a specific actor type
 */
const REMINDER_METHOD_NAME = "receiveReminder"; // the callback method name for the reminder
class ActorManager {
    // dispatcher: ActorMethodDispatcher<T>;
    // timerMethodContext: any;
    // reminderMethodContext: any;
    constructor(actorCls, daprClient) {
        this.serializer = new BufferSerializer_1.default();
        this.daprClient = daprClient;
        this.actorCls = actorCls;
        this.actors = new Map();
        // @todo: we need to make sure race condition cannot happen when accessing the active actors
        // NodeJS has an event loop (main thread -> runs JS code) and a worker pool (threadpool -> automatically created for offloading work through libuv) threads
        // we can have a new thread through the worker_thread module
        // https://medium.com/@mohllal/node-js-multithreading-a5cd74958a67
        //
        //
        // Python: asyncio.lock -> implements a mutex lock for asyncio tasks to guarantee exclusive access to a shared resource
        // Java: Collections.synchronizedMap -> is a thread-saf synchronized map to guarantee serial access
        // NodeJS: https://nodejs.org/api/worker_threads.html
        // this.activeActorsLock = null; // Unknown in JS, states: asyncio.lock() in python @todo: we need a Mutex locking function
        // this.dispatcher = new ActorMethodDispatcher(this.runtimeCtx.getActorTypeInformation());
        // this.timerMethodContext = ActorMethodContext.createForTimer(TIMER_METHOD_NAME);
        // this.reminderMethodContext = ActorMethodContext.createForReminder(REMINDER_METHOD_NAME);
    }
    createActor(actorId) {
        return __awaiter(this, void 0, void 0, function* () {
            return new this.actorCls(this.daprClient, actorId);
        });
    }
    activateActor(actorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const actor = yield this.createActor(actorId);
            // We activate the actor by calling the onActivateInternal method on it
            // this will create its state object
            yield actor.onActivateInternal();
            this.actors.set(actorId.getId(), actor);
        });
    }
    deactivateActor(actorId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.actors.has(actorId.getId())) {
                throw new Error(JSON.stringify({
                    error: "ACTOR_NOT_ACTIVATED",
                    errorMsg: `The actor ${actorId.getId()} was not activated`,
                }));
            }
            const actor = yield this.getActiveActor(actorId);
            yield actor.onDeactivateInternal();
            this.actors.delete(actorId.getId());
        });
    }
    getActiveActor(actorId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.actors.has(actorId.getId())) {
                yield this.activateActor(actorId);
            }
            const actor = this.actors.get(actorId.getId());
            if (!actor) {
                throw new Error(`${actorId.getId()} was not activated correctly`);
            }
            return actor;
        });
    }
    /**
     * Execute the given method with requestBody on the given Actor
     *
     * @param actorId
     * @param actorMethodName
     * @param requestBody
     * @param actorMethodContext
     * @returns
     */
    invoke(actorId, actorMethodName, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const requestBodyDeserialized = this.serializer.deserialize(requestBody || Buffer.from(""));
            return yield this.callActorMethod(actorId, actorMethodName, requestBodyDeserialized);
        });
    }
    fireReminder(actorId, reminderName, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            // @todo: make sure we are remindable
            const requestBodyDeserialized = this.serializer.deserialize(requestBody || Buffer.from(""));
            const reminderData = ActorReminderData_1.default.fromObject(reminderName, requestBodyDeserialized);
            yield this.callActorMethod(actorId, REMINDER_METHOD_NAME, reminderData.state);
        });
    }
    fireTimer(actorId, timerName, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            // @todo: make sure we are remindable
            const requestBodyDeserialized = this.serializer.deserialize(requestBody || Buffer.from(""));
            const timerData = ActorTimerData_1.default.fromObject(timerName, requestBodyDeserialized);
            yield this.callActorMethod(actorId, timerData.callback, timerData.state);
        });
    }
    callActorMethod(actorId, actorMethodName, args) {
        return __awaiter(this, void 0, void 0, function* () {
            const actorObject = yield this.getActiveActor(actorId);
            // Check if the actor method exists? Skip type-checking as it's the power of Javascript
            // @ts-ignore
            if (typeof actorObject[actorMethodName] !== "function") {
                throw new Error(JSON.stringify({
                    error: "ACTOR_METHOD_DOES_NOT_EXIST",
                    errorMsg: `The actor method '${actorMethodName}' does not exist on ${this.actorCls.name}`,
                }));
            }
            // @todo: actor reentrancy
            // Call the actor method, Skip type-checking as it's the power of Javascript
            yield actorObject.onActorMethodPreInternal();
            let res;
            // If we have an array, we passed multiple parameters and should thus spread those
            if (Array.isArray(args)) {
                // @ts-ignore
                res = yield actorObject[actorMethodName](...args);
            }
            else {
                // @ts-ignore
                res = yield actorObject[actorMethodName](args);
            }
            yield actorObject.onActorMethodPostInternal();
            return res;
        });
    }
}
exports.default = ActorManager;
