"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Logger_1 = require("../../logger/Logger");
const ActorClient_1 = __importDefault(require("../client/ActorClient/ActorClient"));
const ActorStateManager_1 = __importDefault(require("./ActorStateManager"));
const StateProvider_1 = __importDefault(require("./StateProvider"));
/**
 * Represents the base class for actors.
 * The base type for actors, that provides the common functionality for actors.
 * The state is preserved across actor garbage collections and fail-overs.
 *
 * Example
 *
 * export default interface IDemoCounterActor extends IActor {
 *   increment(amount: number): void;
 * }
 *
 * export default class DemoActorImpl extends AbstractActor implements IDemoActor {
 *   increment(amount: number): void {
 *     throw new Error("Method not implemented.");
 *   }
 * }
 */
class AbstractActor {
    /**
     * Instantiates a new Actor
     *
     * @param runtimeContext context for the runtime
     * @param id actor identifier
     */
    constructor(daprClient, id) {
        this.daprClient = daprClient;
        this.actorClient = new ActorClient_1.default(daprClient.getDaprHost(), daprClient.getDaprPort(), daprClient.getCommunicationProtocol(), daprClient.getOptions());
        this.logger = new Logger_1.Logger("Actors", "AbstractActor", daprClient.getOptions().logger);
        this.id = id;
        this.stateManager = new ActorStateManager_1.default(this);
        this.daprStateProvider = new StateProvider_1.default(this.actorClient);
        // Interesting one: get the Class Type of the child
        this.actorType = this.constructor.name;
    }
    /**
     * Registers a reminder for this actor
     *
     * Reminders are a mechanism to trigger persistent callbacks on an actor at specified times.
     * Their functionality is similar to timers. But unlike timers, reminders are triggered under
     * all circumstances until the actor explicitly unregisters them or the actor is explicitly
     * deleted. Specifically, reminders are triggered across actor deactivations and failovers
     * because the Actors runtime persists information about the actor's reminders using actor
     * state provider. Also existing reminders can be updated by calling this registration method
     * again using the same reminderName.
     *
     * @todo:
     * https://github.com/dapr/java-sdk/blob/master/sdk-actors/src/main/java/io/dapr/actors/runtime/AbstractActor.java
     * https://github.com/dapr/python-sdk/blob/46c5664d2e75c20122120dab3be882c4d059a987/dapr/actor/runtime/actor.py#L93
     *
     * @param reminderName name of the reminder
     * @param state the state to be send along with the reminder trigger
     * @param dueTime due time for the first trigger
     * @param ttl time to duration after which the reminder will be expired and deleted
     * @param period frequency for the triggers
     * @param <Type> Type of the state object
     * @return Async void response
     */
    registerActorReminder(reminderName, dueTime, period, ttl, state) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.actorClient.actor.registerActorReminder(this.actorType, this.id, reminderName, {
                period,
                dueTime,
                ttl,
                data: state,
            });
        });
    }
    unregisterActorReminder(reminderName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.actorClient.actor.unregisterActorReminder(this.actorType, this.id, reminderName);
        });
    }
    registerActorTimer(timerName, callback, dueTime, period, ttl, state) {
        return __awaiter(this, void 0, void 0, function* () {
            // Register the timer in the sidecar
            return yield this.actorClient.actor.registerActorTimer(this.actorType, this.id, timerName, {
                period,
                dueTime,
                ttl,
                data: state,
                callback,
            });
        });
    }
    unregisterActorTimer(timerName) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.actorClient.actor.unregisterActorTimer(this.actorType, this.id, timerName);
        });
    }
    /**
     * Clears all state cache, calls the overridden onActivate and then saves the states
     * This method gets called when the actor is activated
     * Note: we require this to save the state so that we know the actor got activated!
     */
    onActivateInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetStateInternal();
            yield this.onActivate();
            yield this.saveStateInternal();
        });
    }
    /**
     * Clears all state cache and calls the overridden method onDeactivate
     * This callback is called when an actor is deactivated
     */
    onDeactivateInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resetStateInternal();
            yield this.onDeactivate();
            yield this.saveStateInternal();
        });
    }
    /**
     * Calls the onActorMethodPre hook on the actor implementation
     * This gets called just before executing a method
     */
    onActorMethodPreInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onActorMethodPre();
        });
    }
    /**
     * Calls the onActorMethodPost hook on the actor implementation
     * This gets called just after executing a method
     * It also persists the state changes of the actor
     */
    onActorMethodPostInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.onActorMethodPost();
            // We need to save the state of the actor
            yield this.saveStateInternal();
        });
    }
    /**
     * This will be called when an actor method invocation failed or the actor is activated
     */
    resetStateInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.stateManager.clearCache();
        });
    }
    /**
     * Saves all the state changes (ADD/UPDATE/REMOVE) that were made since the last call
     * to the actor state provider associated with teh actor
     */
    saveStateInternal() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.stateManager.saveState();
        });
    }
    /**
     * This method gets called right after an actor gets activated
     * and before a method call or reminders are dispatched on it
     */
    onActivate() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    /**
     * This method gets called right before an actor gets deactivated
     */
    onDeactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    /**
     * Gets called before executing a method
     * @returns
     */
    onActorMethodPre() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    /**
     * Gets called after executing a method
     * @returns
     */
    onActorMethodPost() {
        return __awaiter(this, void 0, void 0, function* () {
            return;
        });
    }
    receiveReminder(_data) {
        return __awaiter(this, void 0, void 0, function* () {
            this.logger.warn(JSON.stringify({
                error: "ACTOR_METHOD_NOT_IMPLEMENTED",
                errorMsg: `A reminder was created for the actor with id: ${this.id} but the method 'receiveReminder' was not implemented`,
            }));
        });
    }
    getDaprClient() {
        return this.daprClient;
    }
    getStateProvider() {
        return this.daprStateProvider;
    }
    getStateManager() {
        return this.stateManager;
    }
    getActorId() {
        return this.id;
    }
    getActorType() {
        return this.actorType;
    }
}
exports.default = AbstractActor;
