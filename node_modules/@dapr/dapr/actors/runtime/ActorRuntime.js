"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("../..");
const ActorId_1 = __importDefault(require("../ActorId"));
const ActorManager_1 = __importDefault(require("./ActorManager"));
/**
 * Creates instances of "Actor" and activates and deactivates "Actor"
 */
class ActorRuntime {
    // @todo: we need to make sure race condition cannot happen when accessing the active actors
    // NodeJS has an event loop (main thread -> runs JS code) and a worker pool (threadpool -> automatically created for offloading work through libuv) threads
    // we can have a new thread through the worker_thread module
    // https://medium.com/@mohllal/node-js-multithreading-a5cd74958a67
    //
    //
    // Python: asyncio.lock -> implements a mutex lock for asyncio tasks to guarantee exclusive access to a shared resource
    // Java: Collections.synchronizedMap -> is a thread-saf synchronized map to guarantee serial access
    // NodeJS: https://nodejs.org/api/worker_threads.html
    // actorManagersLock
    constructor(daprClient) {
        this.daprClient = daprClient;
        this.actorManagers = new Map();
    }
    static getInstanceByDaprClient(daprClient) {
        if (!ActorRuntime.instance) {
            ActorRuntime.instance = new ActorRuntime(daprClient);
        }
        return ActorRuntime.instance;
    }
    static getInstance(client) {
        if (!ActorRuntime.instance) {
            const daprClient = __1.DaprClient.create(client);
            ActorRuntime.instance = new ActorRuntime(daprClient);
        }
        return ActorRuntime.instance;
    }
    registerActor(actorCls) {
        // Create an ActorManager if it hasn't been registered yet
        if (!this.actorManagers.has(actorCls.name)) {
            this.actorManagers.set(actorCls.name, new ActorManager_1.default(actorCls, this.daprClient));
        }
    }
    getRegisteredActorTypes() {
        return Array.from(this.actorManagers.keys());
    }
    getActorRuntimeOptions() {
        var _a;
        return (_a = this.daprClient.options.actor) !== null && _a !== void 0 ? _a : {};
    }
    setActorRuntimeOptions(options) {
        this.daprClient.options.actor = options;
    }
    clearActorManagers() {
        this.actorManagers = new Map();
    }
    getActorManager(actorTypeName) {
        const actorManager = this.actorManagers.get(actorTypeName);
        if (!actorManager) {
            throw new Error(`ACTOR_TYPE_${actorTypeName}_NOT_REGISTERED`);
        }
        // We need to cast to ActorManager<T> since Map actorManagers
        // is initialized with ActorManager<any> since we don't know the type there
        return actorManager;
    }
    /**
     * Invokes a method on the actor from the runtime
     * This method will open the manager for the actor type and get the matching object
     * It will then invoke the method on this object
     *
     * @param actorTypeName
     * @param actorId
     * @param actorMethodName
     * @param payload
     * @returns
     */
    invoke(actorTypeName, actorId, actorMethodName, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const actorIdObj = new ActorId_1.default(actorId);
            const manager = this.getActorManager(actorTypeName);
            return yield manager.invoke(actorIdObj, actorMethodName, requestBody);
        });
    }
    /**
     * Fires a reminder for the actor
     *
     * @param actorTypeName the name fo the actor type
     * @param actorId the actor id
     * @param name the name of the reminder
     * @param requestBody the body passed to the reminder callback
     */
    fireReminder(actorTypeName, actorId, name, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const actorIdObj = new ActorId_1.default(actorId);
            const manager = this.getActorManager(actorTypeName);
            return yield manager.fireReminder(actorIdObj, name, requestBody);
        });
    }
    /**
     * Fires a timer for the actor
     *
     * @param actorTypeName the name fo the actor type
     * @param actorId the actor id
     * @param name the name of the timer
     * @param requestBody the body passed to the timer callback
     */
    fireTimer(actorTypeName, actorId, name, requestBody) {
        return __awaiter(this, void 0, void 0, function* () {
            const actorIdObj = new ActorId_1.default(actorId);
            const manager = this.getActorManager(actorTypeName);
            return yield manager.fireTimer(actorIdObj, name, requestBody);
        });
    }
    deactivate(actorTypeName, actorId) {
        return __awaiter(this, void 0, void 0, function* () {
            const actorIdObj = new ActorId_1.default(actorId);
            const manager = this.getActorManager(actorTypeName);
            return yield manager.deactivateActor(actorIdObj);
        });
    }
}
exports.default = ActorRuntime;
