import { LoggerOptions } from "../../../types/logger/LoggerOptions";
import { DaprPubSubType } from "../../../types/pubsub/DaprPubSub.type";
import { PubSubSubscriptionsType } from "../../../types/pubsub/PubSubSubscriptions.type";
import { PubSubSubscriptionOptionsType } from "../../../types/pubsub/PubSubSubscriptionOptions.type";
import { PubSubSubscriptionTopicRoutesType } from "../../../types/pubsub/PubSubSubscriptionTopicRoutes.type";
import { IServerType } from "./HTTPServer";
import { TypeDaprPubSubCallback } from "../../../types/DaprPubSubCallback.type";
export default class HTTPServerImpl {
    private readonly PUBSUB_DEFAULT_ROUTE_NAME;
    private readonly PUBSUB_DEFAULT_ROUTE_NAME_DEADLETTER;
    private readonly server;
    private readonly logger;
    pubSubSubscriptions: PubSubSubscriptionsType;
    constructor(server: IServerType, loggerOptions?: LoggerOptions);
    /**
     * When we subscribe, we subscribe to a topic
     * For this topic we can define "routes" which route to a certain callback depending on the event content
     * Each of these topics are handled by a EventHandler but there can be multiple handlers per pubsubname-topic-route combination
     *
     * We don't create the EventHandlers here but we ensure that the routes are registered and can receive POST events
     * -> we create POST /<route> endpoints for each, but we create them uniquely!
     * -> to ensure uniqueness, we just check if this.pubsubRouteEventHandlers[route] is set
     *
     * @param pubSubName
     * @param topicName
     * @param cb
     * @param options
     */
    registerPubsubSubscription(pubsubName: string, topic: string, options?: PubSubSubscriptionOptionsType): void;
    registerPubSubSubscriptionEventHandler(pubsubName: string, topic: string, route: string | undefined, cb: TypeDaprPubSubCallback): void;
    generatePubSubSubscriptionTopicRouteName(route?: string): string;
    generatePubSubSubscriptionTopicRoutes(pubsubName: string, topic: string, options?: PubSubSubscriptionOptionsType): PubSubSubscriptionTopicRoutesType;
    generateDaprSubscriptionRoute(pubsubName: string, topic: string, route?: string): string;
    /**
     * Generate a subscription object that will be used in the /dapr/subscribe endpoint
     * this will let dapr know that we have subscriptions and how they map to routes / deadletter
     *
     * Important: we internally translate the provided /example to -> /<pubsubname>-<topic>-example
     *            or if empty to /<pubsubname>-<topic>-default
     *            this is to ensure that HTTP Server endpoints are unique
     *
     * @param pubsubName
     * @param topic
     * @param options
     * @returns
     */
    generateDaprPubSubSubscription(pubsubName: string, topic: string, options?: PubSubSubscriptionOptionsType): DaprPubSubType;
    generateDaprPubSubSubscriptionList(): DaprPubSubType[];
    /**
     * We generate a event handler key based on the path or the route
     * If the route is just a string, that is the path
     * Else the path is configured through a rule of DaprPubSubRuleType
     *
     * @param pubsubName
     * @param topic
     * @param route
     * @returns
     */
    generatePubsubPath(pubsubName: string, topic: string, route: string): string;
}
