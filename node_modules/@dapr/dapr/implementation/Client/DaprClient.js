"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const binding_1 = __importDefault(require("./GRPCClient/binding"));
const pubsub_1 = __importDefault(require("./GRPCClient/pubsub"));
const state_1 = __importDefault(require("./GRPCClient/state"));
const invoker_1 = __importDefault(require("./GRPCClient/invoker"));
const secret_1 = __importDefault(require("./GRPCClient/secret"));
const health_1 = __importDefault(require("./GRPCClient/health"));
const metadata_1 = __importDefault(require("./GRPCClient/metadata"));
const sidecar_1 = __importDefault(require("./GRPCClient/sidecar"));
const configuration_1 = __importDefault(require("./GRPCClient/configuration"));
const lock_1 = __importDefault(require("./GRPCClient/lock"));
const actor_1 = __importDefault(require("./GRPCClient/actor"));
const GRPCClient_1 = __importDefault(require("./GRPCClient/GRPCClient"));
const binding_2 = __importDefault(require("./HTTPClient/binding"));
const pubsub_2 = __importDefault(require("./HTTPClient/pubsub"));
const state_2 = __importDefault(require("./HTTPClient/state"));
const invoker_2 = __importDefault(require("./HTTPClient/invoker"));
const secret_2 = __importDefault(require("./HTTPClient/secret"));
const health_2 = __importDefault(require("./HTTPClient/health"));
const metadata_2 = __importDefault(require("./HTTPClient/metadata"));
const sidecar_2 = __importDefault(require("./HTTPClient/sidecar"));
const configuration_2 = __importDefault(require("./HTTPClient/configuration"));
const proxy_1 = __importDefault(require("./HTTPClient/proxy"));
const lock_2 = __importDefault(require("./HTTPClient/lock"));
const actor_2 = __importDefault(require("./HTTPClient/actor"));
const HTTPClient_1 = __importDefault(require("./HTTPClient/HTTPClient"));
const CommunicationProtocol_enum_1 = __importDefault(require("../../enum/CommunicationProtocol.enum"));
const Settings_util_1 = require("../../utils/Settings.util");
const Logger_1 = require("../../logger/Logger");
const proxy_2 = __importDefault(require("./GRPCClient/proxy"));
const NodeJSUtils = __importStar(require("../../utils/NodeJS.util"));
const version_1 = require("../../version");
class DaprClient {
    constructor(daprHost, daprPort, communicationProtocol = CommunicationProtocol_enum_1.default.HTTP, options = {}) {
        this.daprHost = daprHost !== null && daprHost !== void 0 ? daprHost : Settings_util_1.Settings.getDefaultHost();
        this.daprPort = daprPort !== null && daprPort !== void 0 ? daprPort : Settings_util_1.Settings.getDefaultPort(communicationProtocol);
        this.communicationProtocol = communicationProtocol;
        this.options = options;
        this.logger = new Logger_1.Logger("DaprClient", "DaprClient", this.options.logger);
        // Validation on port
        if (!/^[0-9]+$/.test(this.daprPort)) {
            throw new Error("DAPR_INCORRECT_SIDECAR_PORT");
        }
        if (String(version_1.SDK_PACKAGE_NAME) === "dapr-client") {
            this.logger.warn("dapr-client is deprecated. Please use @dapr/dapr instead. For more information, see https://github.com/dapr/js-sdk/issues/259");
        }
        // Builder
        switch (communicationProtocol) {
            case CommunicationProtocol_enum_1.default.GRPC: {
                const client = new GRPCClient_1.default(this.daprHost, this.daprPort, this.options);
                this.daprClient = client;
                this.state = new state_1.default(client);
                this.pubsub = new pubsub_1.default(client);
                this.binding = new binding_1.default(client);
                this.invoker = new invoker_1.default(client);
                this.secret = new secret_1.default(client);
                this.health = new health_1.default(client);
                this.metadata = new metadata_1.default(client);
                this.sidecar = new sidecar_1.default(client);
                this.proxy = new proxy_2.default(client);
                this.configuration = new configuration_1.default(client);
                this.lock = new lock_1.default(client);
                this.actor = new actor_1.default(client); // we use a abstractor here since we interface through a builder with the Actor Runtime
                break;
            }
            case CommunicationProtocol_enum_1.default.HTTP:
            default: {
                const client = new HTTPClient_1.default(this.daprHost, this.daprPort, this.options);
                this.daprClient = client;
                this.state = new state_2.default(client);
                this.pubsub = new pubsub_2.default(client);
                this.binding = new binding_2.default(client);
                this.invoker = new invoker_2.default(client);
                this.secret = new secret_2.default(client);
                this.health = new health_2.default(client);
                this.metadata = new metadata_2.default(client);
                this.sidecar = new sidecar_2.default(client);
                this.configuration = new configuration_2.default(client);
                this.proxy = new proxy_1.default(client);
                this.lock = new lock_2.default(client);
                this.actor = new actor_2.default(client); // we use a abstractor here since we interface through a builder with the Actor Runtime
                break;
            }
        }
    }
    static create(client) {
        return new DaprClient(client.getClientHost(), client.getClientPort(), client.getClientCommunicationProtocol(), client.getOptions());
    }
    static awaitSidecarStarted(fnIsSidecarStarted, logger) {
        return __awaiter(this, void 0, void 0, function* () {
            // Dapr will probe every 50ms to see if we are listening on our port: https://github.com/dapr/dapr/blob/a43712c97ead550ca2f733e9f7e7769ecb195d8b/pkg/runtime/runtime.go#L1694
            // if we are using actors we will change this to 4s to let the placement tables update
            let isStarted = yield fnIsSidecarStarted();
            let isStartedRetryCount = 0;
            const isStartedMaxRetryCount = 60; // 1s startup delay and we try max for 60s
            if (isStarted) {
                return;
            }
            logger.info(`Awaiting Sidecar to be Started`);
            while (!isStarted) {
                logger.verbose(`Waiting for the Dapr Sidecar to start, retry count: (#${isStartedRetryCount})`);
                yield NodeJSUtils.sleep(Settings_util_1.Settings.getDaprSidecarPollingDelayMs());
                // Implement API call manually as we need to enable calling without initialization
                // everything routes through the `execute` method
                // to check health, we just ping the /metadata endpoint and see if we get a response
                isStarted = yield fnIsSidecarStarted();
                // Finally, Handle the retry logic
                isStartedRetryCount++;
                if (isStartedRetryCount > isStartedMaxRetryCount) {
                    throw new Error("DAPR_SIDECAR_COULD_NOT_BE_STARTED");
                }
            }
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.daprClient.stop();
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.daprClient.start();
        });
    }
    getDaprClient() {
        return this.daprClient;
    }
    getDaprHost() {
        return this.daprHost;
    }
    getDaprPort() {
        return this.daprPort;
    }
    getOptions() {
        return this.options;
    }
    getCommunicationProtocol() {
        return this.communicationProtocol;
    }
    getIsInitialized() {
        return this.daprClient.getIsInitialized();
    }
}
exports.default = DaprClient;
