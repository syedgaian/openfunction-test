"use strict";
/*
Copyright 2022 The Dapr Authors
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fetch_1 = __importDefault(require("node-fetch"));
const __1 = require("../../..");
const http_1 = __importDefault(require("http"));
const https_1 = __importDefault(require("https"));
const Settings_util_1 = require("../../../utils/Settings.util");
const Logger_1 = require("../../../logger/Logger");
const sidecar_1 = __importDefault(require("./sidecar"));
const version_1 = require("../../../version");
class HTTPClient {
    constructor(host = Settings_util_1.Settings.getDefaultHost(), port = Settings_util_1.Settings.getDefaultHttpPort(), options = {}) {
        this.clientHost = host;
        this.clientPort = port;
        this.options = options;
        this.logger = new Logger_1.Logger("HTTPClient", "HTTPClient", this.options.logger);
        this.isInitialized = false;
        // fallback to default
        if (this.options.isKeepAlive === undefined) {
            this.options.isKeepAlive = true;
        }
        if (!this.clientHost.startsWith("http://") && !this.clientHost.startsWith("https://")) {
            this.clientUrl = `http://${this.clientHost}:${this.clientPort}/v1.0`;
        }
        else {
            this.clientUrl = `${this.clientHost}:${this.clientPort}/v1.0`;
        }
        if (!HTTPClient.client) {
            HTTPClient.client = node_fetch_1.default;
        }
        // Add a custom agent so we can decide if we want to reuse connections or not
        // we use an agent so we can reuse an open connection, limiting handshake requirements
        // Note: when using an agent, we will encounter TCPWRAP since the connection doesn't get destroyed
        const keepAlive = this.options.isKeepAlive;
        const keepAliveMsecs = 30 * 1000; // it is applicable only when keepAlive is set to true
        if (!HTTPClient.httpAgent) {
            HTTPClient.httpAgent = new http_1.default.Agent({ keepAlive: keepAlive, keepAliveMsecs: keepAliveMsecs });
        }
        if (!HTTPClient.httpsAgent) {
            HTTPClient.httpsAgent = new https_1.default.Agent({ keepAlive: keepAlive, keepAliveMsecs: keepAliveMsecs });
        }
    }
    getClient(requiresInitialization = true) {
        return __awaiter(this, void 0, void 0, function* () {
            // Ensure the sidecar has been started
            if (requiresInitialization && !this.isInitialized) {
                this.logger.verbose("Client is not initialized, starting sidecar and initializing");
                yield this.start();
            }
            return HTTPClient.client;
        });
    }
    getClientHost() {
        return this.clientHost;
    }
    getClientPort() {
        return this.clientPort;
    }
    getClientUrl() {
        return this.clientUrl;
    }
    getClientCommunicationProtocol() {
        return __1.CommunicationProtocolEnum.HTTP;
    }
    getOptions() {
        return this.options;
    }
    setIsInitialized(isInitialized) {
        this.isInitialized = isInitialized;
    }
    getIsInitialized() {
        return this.isInitialized;
    }
    _startAwaitSidecarStarted() {
        return __awaiter(this, void 0, void 0, function* () {
            yield __1.DaprClient.awaitSidecarStarted(() => __awaiter(this, void 0, void 0, function* () { return yield sidecar_1.default.isStarted(this); }), this.logger);
        });
    }
    stop() {
        return __awaiter(this, void 0, void 0, function* () {
            HTTPClient.httpAgent.destroy();
            HTTPClient.httpsAgent.destroy();
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._startAwaitSidecarStarted();
            this.isInitialized = true;
            this.logger.info("Sidecar Started");
            return;
        });
    }
    executeWithApiVersion(apiVersion = "v1.0", url, params = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const newClientUrl = this.clientUrl.replace("v1.0", apiVersion);
            return yield this.execute(`${newClientUrl}${url}`, params);
        });
    }
    /**
     *
     * @param url The URL to call
     * @param params The parameters to pass to our URL
     * @param requiresInitialization If false, it doesn't require the Dapr sidecar to be started and might fail
     * @returns The result of the call
     */
    execute(url, params, requiresInitialization = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!params || typeof params !== "object") {
                params = {
                    method: "GET",
                };
            }
            if (!(params === null || params === void 0 ? void 0 : params.headers)) {
                params.headers = {};
            }
            if (this.options.daprApiToken) {
                params.headers["dapr-api-token"] = this.options.daprApiToken;
            }
            params.headers["user-agent"] = `dapr-sdk-js/v${version_1.SDK_VERSION} http/1`;
            if (!(params === null || params === void 0 ? void 0 : params.method)) {
                params.method = "GET";
            }
            if ((params === null || params === void 0 ? void 0 : params.body) && !(params === null || params === void 0 ? void 0 : params.headers["Content-Type"])) {
                switch (typeof (params === null || params === void 0 ? void 0 : params.body)) {
                    case "object":
                        params.headers["Content-Type"] = "application/json";
                        params.body = JSON.stringify(params === null || params === void 0 ? void 0 : params.body);
                        break;
                    case "string":
                        params.headers["Content-Type"] = "text/plain";
                        break;
                    default:
                        this.logger.warn(`Unknown body type: ${typeof (params === null || params === void 0 ? void 0 : params.body)}, defaulting to "text/plain"`);
                        params.headers["Content-Type"] = "text/plain";
                        break;
                }
            }
            const urlFull = url.startsWith("http") ? url : `${this.clientUrl}${url}`;
            const agent = urlFull.startsWith("https") ? HTTPClient.httpsAgent : HTTPClient.httpAgent;
            params.agent = agent;
            this.logger.debug(`Fetching ${params.method} ${urlFull} with body: (${params.body})`);
            const client = yield this.getClient(requiresInitialization);
            const res = yield client(urlFull, params);
            // Parse body
            const txt = yield res.text();
            let txtParsed;
            try {
                txtParsed = JSON.parse(txt);
            }
            catch (e) {
                txtParsed = txt;
            }
            // 2XX -> OK; 3XX -> Redirects and Found
            if (res.status >= 200 && res.status <= 399) {
                return txtParsed;
            }
            // All the others
            else {
                this.logger.debug(`Execute response with  status: ${res.status} and text: ${txtParsed}`);
                throw new Error(JSON.stringify({
                    error: "UNKNOWN",
                    error_msg: `An unknown problem occurred and we got the status ${res.status} with response ${JSON.stringify(res)}`,
                    status: res.status,
                }));
            }
        });
    }
}
exports.default = HTTPClient;
