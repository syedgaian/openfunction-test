import fetch from "node-fetch";
import { CommunicationProtocolEnum } from "../../..";
import IClient from "../../../interfaces/Client/IClient";
import { DaprClientOptions } from "../../../types/DaprClientOptions";
import { THTTPExecuteParams } from "../../../types/http/THTTPExecuteParams.type";
export default class HTTPClient implements IClient {
    private isInitialized;
    private static client;
    private readonly clientHost;
    private readonly clientPort;
    private readonly clientUrl;
    private readonly options;
    private readonly logger;
    private static httpAgent;
    private static httpsAgent;
    constructor(host?: string, port?: string, options?: DaprClientOptions);
    getClient(requiresInitialization?: boolean): Promise<typeof fetch>;
    getClientHost(): string;
    getClientPort(): string;
    getClientUrl(): string;
    getClientCommunicationProtocol(): CommunicationProtocolEnum;
    getOptions(): DaprClientOptions;
    setIsInitialized(isInitialized: boolean): void;
    getIsInitialized(): boolean;
    _startAwaitSidecarStarted(): Promise<void>;
    stop(): Promise<void>;
    start(): Promise<void>;
    executeWithApiVersion(apiVersion: string | undefined, url: string, params?: any): Promise<object | string>;
    /**
     *
     * @param url The URL to call
     * @param params The parameters to pass to our URL
     * @param requiresInitialization If false, it doesn't require the Dapr sidecar to be started and might fail
     * @returns The result of the call
     */
    execute(url: string, params?: THTTPExecuteParams | undefined | null, requiresInitialization?: boolean): Promise<object | string>;
}
