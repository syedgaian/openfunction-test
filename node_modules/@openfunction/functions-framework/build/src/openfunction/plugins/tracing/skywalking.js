"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _SkyWalking_instances, _SkyWalking_component_get, _SkyWalking_getCarrier;
Object.defineProperty(exports, "__esModule", { value: true });
const Debug = require("debug");
const lodash_1 = require("lodash");
const skywalking_backend_js_1 = require("skywalking-backend-js");
const Tag_1 = require("skywalking-backend-js/lib/Tag");
const Component_1 = require("skywalking-backend-js/lib/trace/Component");
const ContextCarrier_1 = require("skywalking-backend-js/lib/trace/context/ContextCarrier");
const Tracing_pb_1 = require("skywalking-backend-js/lib/proto/language-agent/Tracing_pb");
const _1 = require(".");
const debug = Debug('ofn:plugin:tracing');
/**
 * SkyWalking specific implementation of tracer plugin.
 * See also: https://github.com/apache/skywalking-data-collect-protocol/blob/master/language-agent/Tracing.proto
 */
class SkyWalking extends _1.default {
    constructor() {
        super(...arguments);
        _SkyWalking_instances.add(this);
    }
    /**
     * It starts the SkyWalking tracer agent.
     */
    async startAgent() {
        var _a, _b;
        // AgentConfig: https://github.com/apache/skywalking-nodejs/blob/master/src/config/AgentConfig.ts
        skywalking_backend_js_1.default.start({
            serviceName: (_a = this.config.tags) === null || _a === void 0 ? void 0 : _a.func,
            collectorAddress: ((_b = this.config.provider) === null || _b === void 0 ? void 0 : _b.oapServer) || '127.0.0.1:11800',
            // FIXME: NO span could be recorded with "http" plugin enabled
            // FIXME: "express" plugin will block error span record
            disablePlugins: 'http,express',
        });
    }
    /**
     * It creates a new entry span, sets the span layer to FAAS, and sets the span tags.
     * @param ctx - OpenFunctionRuntime - The context object that is passed to the function.
     */
    async startSpan(ctx) {
        var _a, _b, _c;
        const context = skywalking_backend_js_1.ContextManager.current;
        const span = (_a = skywalking_backend_js_1.ContextManager.currentSpan) !== null && _a !== void 0 ? _a : context.newEntrySpan('/', __classPrivateFieldGet(this, _SkyWalking_instances, "m", _SkyWalking_getCarrier).call(this, ctx));
        span.operation = (0, lodash_1.get)(ctx, 'name');
        span.component = __classPrivateFieldGet(this, _SkyWalking_instances, "a", _SkyWalking_component_get);
        span.layer = Tracing_pb_1.SpanLayer.FAAS;
        // Pass through some typical tags per the context
        span.tag({
            key: 'runtime',
            val: (0, lodash_1.get)(ctx, 'runtime'),
            overridable: false,
        });
        if (ctx.req) {
            span.tag(Tag_1.default.httpMethod((_b = ctx.req) === null || _b === void 0 ? void 0 : _b.method));
            span.tag(Tag_1.default.httpURL((_c = ctx.req) === null || _c === void 0 ? void 0 : _c.originalUrl));
        }
        // Pass through user defined "tags" data
        (0, lodash_1.forEach)(this.config.tags, (val, key) => {
            span.tag({
                key,
                val,
                overridable: false,
            });
        });
        // Start the span once all set
        // span.async();
        span.start();
        // FIXME: SkyWalking Node.js SDK has not implemented "sw-correlation" injection,
        // so we cannot deal with "baggage" data passed through tracer plugin options
        // Save back trace id for potential future use
        ctx.locals.traceId = context.traceId();
        debug('Span trace id: %s', ctx.locals.traceId);
    }
    /**
     * It stops the current span, and if there was an error, it marks the span as an error.
     * @param ctx - OpenFunctionRuntime - The context object that is passed to the function.
     */
    async stopSpan(ctx) {
        const span = skywalking_backend_js_1.ContextManager.currentSpan;
        ctx.error && span.error(ctx.error);
        span.stop();
        // NOTE: `flush` may take some time
        await skywalking_backend_js_1.default.flush();
    }
}
exports.default = SkyWalking;
_SkyWalking_instances = new WeakSet(), _SkyWalking_component_get = function _SkyWalking_component_get() {
    return new Component_1.Component(5013);
}, _SkyWalking_getCarrier = function _SkyWalking_getCarrier(ctx) {
    var _a;
    return ContextCarrier_1.ContextCarrier.from((_a = ctx.req) === null || _a === void 0 ? void 0 : _a.headers);
};
//# sourceMappingURL=skywalking.js.map