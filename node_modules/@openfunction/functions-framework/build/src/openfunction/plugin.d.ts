import { OpenFunctionRuntime } from './runtime';
/**
 * Defining an abstract class to represent Plugin.
 * @public
 **/
export declare class Plugin {
    /**
     * Name of the plugin.
     */
    readonly name: string;
    /**
     * Version of the plugin.
     */
    readonly version: string;
    /**
     * Constructor of the OpenFunction plugin.
     */
    constructor(name: string, version?: string);
    /**
     * Get the value of a property on the plugin.
     * @param prop - The property to get.
     * @returns The value of the property.
     */
    get(prop: string): string extends infer T ? T extends string ? T extends keyof this ? this[T] : T extends `${infer FieldKey}[${infer IndexKey}]` ? FieldKey extends keyof this ? import("lodash").IndexedFieldWithPossiblyUndefined<this[FieldKey], IndexKey> : undefined : undefined : never : never;
    /**
     * This function is called before the user function is executed.
     * @param ctx - Object that contains information about the function that is being executed.
     * @param plugins - The collection of loaded pre and post hook plugins.
     */
    execPreHook(ctx: OpenFunctionRuntime | null, plugins: Record<string, Plugin>): Promise<void>;
    /**
     * This function is called after the user function is executed.
     * @param ctx - Object that contains information about the function that is being executed.
     * @param plugins - The collection of loaded pre and post hook plugins.
     */
    execPostHook(ctx: OpenFunctionRuntime | null, plugins: Record<string, Plugin>): Promise<void>;
}
/**
 * PluginMap type definition.
 */
export declare type PluginMap = Record<string, Plugin> & {
    _seq?: string[];
};
declare enum PluginStoreType {
    BUILTIN = 1,
    CUSTOM = 2
}
/**
 * PluginStore is a class that manages a collection of plugins.
 **/
export declare class PluginStore {
    #private;
    /**
     * Type of the plugin store.
     */
    static Type: typeof PluginStoreType;
    /**
     * Singleton helper method to create PluginStore instance.
     * @param type - PluginStoreType - The type of plugin store you want to create.
     * @returns A new instance of the PluginStore class.
     */
    static Instance(type?: PluginStoreType): PluginStore;
    /**
     * Private constructor of PluginStore.
     * @param type - PluginStoreType - The type of store you want to use.
     */
    private constructor();
    /**
     * Adds a plugin to the store.
     * @param plugin - Plugin - The plugin to register.
     */
    register(plugin: Plugin): void;
    /**
     * Removes a plugin from the store.
     * @param plugin - Plugin - The plugin to register.
     */
    unregister(plugin: Plugin): void;
    /**
     * Return the plugin with the given name from the store.
     * @param name - The name of the plugin.
     * @returns The plugin object.
     */
    get(name: string): Plugin;
    /**
     * It invokes the `execPreHook` function of each plugin in the order specified by the `seq` array
     * @param ctx - The context object that is passed to the plugin.
     * @param [seq] - The sequence of plugins to be executed. If not specified, all plugins will be executed.
     */
    execPreHooks(ctx: OpenFunctionRuntime | null, seq?: string[]): Promise<void>;
    /**
     * It invokes the `execPostHook` function of each plugin in the order specified by the `seq` array
     * @param ctx - The context object that is passed to the plugin.
     * @param [seq] - The sequence of plugins to be executed. If not specified, all plugins will be executed.
     */
    execPostHooks(ctx: OpenFunctionRuntime | null, seq?: string[]): Promise<void>;
}
export {};
//# sourceMappingURL=plugin.d.ts.map