"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _PluginStore_instances, _PluginStore_type, _PluginStore_store, _PluginStore_isCustomStore_get, _PluginStore_invokePluginBySeq;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginStore = exports.Plugin = void 0;
/* eslint-disable @typescript-eslint/no-unused-vars */
const Debug = require("debug");
const lodash_1 = require("lodash");
const debug = Debug('ofn:plugin');
/**
 * Defining an abstract class to represent Plugin.
 * @public
 **/
class Plugin {
    /**
     * Constructor of the OpenFunction plugin.
     */
    constructor(name, version = 'unknown') {
        if (!(0, lodash_1.trim)(name)) {
            throw new Error('Plugin name must be specified.');
        }
        this.name = name;
        this.version = version;
    }
    /**
     * Get the value of a property on the plugin.
     * @param prop - The property to get.
     * @returns The value of the property.
     */
    get(prop) {
        return (0, lodash_1.get)(this, prop);
    }
    /**
     * This function is called before the user function is executed.
     * @param ctx - Object that contains information about the function that is being executed.
     * @param plugins - The collection of loaded pre and post hook plugins.
     */
    async execPreHook(ctx, plugins) {
        console.warn(`Plugin "${this.name}" has not implemented pre hook function.`);
    }
    /**
     * This function is called after the user function is executed.
     * @param ctx - Object that contains information about the function that is being executed.
     * @param plugins - The collection of loaded pre and post hook plugins.
     */
    async execPostHook(ctx, plugins) {
        console.warn(`Plugin "${this.name}" has not implemented post hook function.`);
    }
}
exports.Plugin = Plugin;
var PluginStoreType;
(function (PluginStoreType) {
    PluginStoreType[PluginStoreType["BUILTIN"] = 1] = "BUILTIN";
    PluginStoreType[PluginStoreType["CUSTOM"] = 2] = "CUSTOM";
})(PluginStoreType || (PluginStoreType = {}));
/**
 * Initializes a store object for PluginStore singleton class
 * with the keys of the PluginStoreType enum and the values of an empty object.
 **/
const stores = (0, lodash_1.transform)(PluginStoreType, (r, k, v) => {
    r[v] = { _seq: [] };
}, {});
/**
 * PluginStore is a class that manages a collection of plugins.
 **/
class PluginStore {
    /**
     * Private constructor of PluginStore.
     * @param type - PluginStoreType - The type of store you want to use.
     */
    constructor(type) {
        _PluginStore_instances.add(this);
        /**
         * Internal store type.
         */
        _PluginStore_type.set(this, PluginStoreType.CUSTOM);
        /**
         * Internal store object.
         */
        _PluginStore_store.set(this, null);
        if (!__classPrivateFieldGet(this, _PluginStore_store, "f")) {
            __classPrivateFieldSet(this, _PluginStore_type, type, "f");
            __classPrivateFieldSet(this, _PluginStore_store, stores[type], "f");
        }
    }
    /**
     * Singleton helper method to create PluginStore instance.
     * @param type - PluginStoreType - The type of plugin store you want to create.
     * @returns A new instance of the PluginStore class.
     */
    static Instance(type = PluginStore.Type.CUSTOM) {
        return new PluginStore(type);
    }
    /**
     * Adds a plugin to the store.
     * @param plugin - Plugin - The plugin to register.
     */
    register(plugin) {
        var _a;
        __classPrivateFieldGet(this, _PluginStore_store, "f")[plugin.name] = plugin;
        (_a = __classPrivateFieldGet(this, _PluginStore_store, "f")._seq) === null || _a === void 0 ? void 0 : _a.push(plugin.name);
    }
    /**
     * Removes a plugin from the store.
     * @param plugin - Plugin - The plugin to register.
     */
    unregister(plugin) {
        delete __classPrivateFieldGet(this, _PluginStore_store, "f")[plugin.name];
        (0, lodash_1.omit)(__classPrivateFieldGet(this, _PluginStore_store, "f")._seq, plugin.name);
    }
    /**
     * Return the plugin with the given name from the store.
     * @param name - The name of the plugin.
     * @returns The plugin object.
     */
    get(name) {
        return __classPrivateFieldGet(this, _PluginStore_store, "f")[name];
    }
    /**
     * It invokes the `execPreHook` function of each plugin in the order specified by the `seq` array
     * @param ctx - The context object that is passed to the plugin.
     * @param [seq] - The sequence of plugins to be executed. If not specified, all plugins will be executed.
     */
    async execPreHooks(ctx, seq) {
        await __classPrivateFieldGet(this, _PluginStore_instances, "m", _PluginStore_invokePluginBySeq).call(this, ctx, 'execPreHook', seq || (__classPrivateFieldGet(this, _PluginStore_instances, "a", _PluginStore_isCustomStore_get) && (0, lodash_1.get)(ctx, 'prePlugins')) || []);
    }
    /**
     * It invokes the `execPostHook` function of each plugin in the order specified by the `seq` array
     * @param ctx - The context object that is passed to the plugin.
     * @param [seq] - The sequence of plugins to be executed. If not specified, all plugins will be executed.
     */
    async execPostHooks(ctx, seq) {
        await __classPrivateFieldGet(this, _PluginStore_instances, "m", _PluginStore_invokePluginBySeq).call(this, ctx, 'execPostHook', seq || (__classPrivateFieldGet(this, _PluginStore_instances, "a", _PluginStore_isCustomStore_get) && (0, lodash_1.get)(ctx, 'postPlugins')) || []);
    }
}
exports.PluginStore = PluginStore;
_PluginStore_type = new WeakMap(), _PluginStore_store = new WeakMap(), _PluginStore_instances = new WeakSet(), _PluginStore_isCustomStore_get = function _PluginStore_isCustomStore_get() {
    return __classPrivateFieldGet(this, _PluginStore_type, "f") === PluginStoreType.CUSTOM;
}, _PluginStore_invokePluginBySeq = 
/**
 * It invokes a method on each plugin in the sequence.
 * @param ctx - OpenFunctionRuntime context object.
 * @param method - The method to invoke on the plugin.
 * @param [seq] - The sequence of plugins to invoke. If not provided, the default sequence will be used.
 */
async function _PluginStore_invokePluginBySeq(ctx, method, seq) {
    var _a;
    const pluginNames = !(0, lodash_1.isEmpty)(seq) ? seq : (_a = __classPrivateFieldGet(this, _PluginStore_store, "f")._seq) !== null && _a !== void 0 ? _a : [];
    const plugins = __classPrivateFieldGet(this, _PluginStore_store, "f");
    for (const pluginName of pluginNames) {
        const plugin = plugins[pluginName];
        debug('Executing "%s" of plugin "%s"', method, pluginName);
        // Try to invoke the plugin method and catch exceptions
        try {
            await (0, lodash_1.invoke)(plugin, method, ctx, plugins);
        }
        catch (ex) {
            const err = ex;
            console.error(`Failed to invoke "${method}" of plugin "${pluginName}"` +
                `\nDetailed stack trace: ${err.stack}`);
        }
    }
};
/**
 * Type of the plugin store.
 */
PluginStore.Type = PluginStoreType;
//# sourceMappingURL=plugin.js.map