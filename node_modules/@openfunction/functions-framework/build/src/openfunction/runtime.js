"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenFunctionRuntime = void 0;
const process_1 = require("process");
const lodash_1 = require("lodash");
const dapr_1 = require("@dapr/dapr");
const context_1 = require("./context");
const plugin_1 = require("./plugin");
/**
 * The OpenFunction's serving runtime abstract class.
 * @public
 */
class OpenFunctionRuntime {
    /**
     * Constructor of the OpenFunctionRuntime.
     */
    constructor(context) {
        this.context = context;
        this.locals = {};
    }
    /**
     * Static method to parse the context and get runtime.
     */
    static Parse(context) {
        return new DaprRuntime(context);
    }
    /**
     * It creates a proxy for the runtime object, which delegates all property access to the runtime object
     * @param context - The context object to be proxied.
     * @returns The proxy object.
     */
    static ProxyContext(context) {
        // Get a proper runtime for the context
        const runtime = OpenFunctionRuntime.Parse(context);
        // Create a proxy for the context
        return new Proxy(runtime, {
            get: (target, prop) => {
                // Provide delegated property access of the context object
                if ((0, lodash_1.has)(target.context, prop))
                    return (0, lodash_1.get)(target.context, prop);
                // Otherwise, return the property of the runtime object
                else
                    return Reflect.get(target, prop);
            },
        });
    }
    /**
     * It takes a user function and a context object, and returns a function that executes the user
     * function with the context object, and executes all the pre and post hooks before and after the user function.
     * @param userFunction - The function that you want to wrap.
     * @param context - This is the context object that is passed to the user function.
     * @returns A function that takes in data and returns a promise.
     */
    static WrapUserFunction(userFunction, context
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    ) {
        const ctx = !(0, lodash_1.isPlainObject)(context)
            ? context
            : OpenFunctionRuntime.ProxyContext(context);
        // Load plugin stores
        const userPlugins = plugin_1.PluginStore.Instance();
        const sysPlugins = plugin_1.PluginStore.Instance(plugin_1.PluginStore.Type.BUILTIN);
        return async (data) => {
            // Execute pre hooks, user plugins go first
            await userPlugins.execPreHooks(ctx);
            await sysPlugins.execPreHooks(ctx);
            // Execute user function and save error for lazy reporting
            try {
                await userFunction(ctx, data);
            }
            catch (ex) {
                ctx.error = ex;
            }
            // Execute pre hooks, user plugins go last
            await sysPlugins.execPostHooks(ctx);
            await userPlugins.execPostHooks(ctx);
            // Report error if exists at the very last
            if (ctx.error)
                throw ctx.error;
        };
    }
    /**
     * Getter for the port of Dapr sidecar
     */
    get sidecarPort() {
        return {
            HTTP: process_1.env.DAPR_HTTP_PORT || '3500',
            GRRC: process_1.env.DAPR_GRPC_PORT || '50001',
        };
    }
    /**
     * Getter returns the request object from the trigger.
     * @returns The request object.
     */
    get req() {
        var _a;
        return (_a = this.trigger) === null || _a === void 0 ? void 0 : _a.req;
    }
    /**
     * Getter returns the response object from the trigger.
     * @returns The res property of the trigger object.
     */
    get res() {
        var _a;
        return (_a = this.trigger) === null || _a === void 0 ? void 0 : _a.res;
    }
    /**
     * It sets the trigger object to the request and response objects passed in
     * @param req - The HTTP request object
     * @param res - The HTTP response object
     */
    setTrigger(req, res) {
        this.trigger = (0, lodash_1.extend)(this.trigger, { req, res });
    }
    /**
     * Get a plugin from the plugin store, or if it doesn't exist, get it from the built-in plugin store.
     *
     * @param name - The name of the plugin to get.
     * @returns A plugin object
     */
    getPlugin(name) {
        return (plugin_1.PluginStore.Instance().get(name) ||
            plugin_1.PluginStore.Instance(plugin_1.PluginStore.Type.BUILTIN).get(name));
    }
}
exports.OpenFunctionRuntime = OpenFunctionRuntime;
/**
 * Dapr runtime class derived from OpenFunctionRuntime.
 */
class DaprRuntime extends OpenFunctionRuntime {
    /**
     * Constructor of the DaprRuntime.
     */
    constructor(context) {
        super(context);
        /**
         * NOTE: GRPC is not well supported so far in Dapr Node.js SDK
         * TODO: Should determine whether to use GRPC channel
         */
        this.daprClient = new dapr_1.DaprClient(process.env.DAPR_HOST, this.sidecarPort.HTTP, dapr_1.CommunicationProtocolEnum.HTTP);
    }
    /**
     * Send data to the Dapr runtime (sidecar).
     * @param {object} data - The data to send to the output.
     * @param {string} [output] - The output to send the data to.
     * @returns The promise of the actions being executed.
     */
    send(data, output) {
        const actions = (0, lodash_1.chain)(this.context.outputs)
            .filter((v, k) => !output || k === output)
            .map((component) => {
            if (context_1.ContextUtils.IsBindingComponent(component)) {
                return this.daprClient.binding.send(component.componentName, component.operation || '', data, component.metadata);
            }
            else if (context_1.ContextUtils.IsPubSubComponent(component)) {
                return this.daprClient.pubsub.publish(component.componentName, component.uri || '', data);
            }
            return Promise.resolve(undefined);
        })
            .value();
        return Promise.allSettled(actions);
    }
}
//# sourceMappingURL=runtime.js.map